# 原始
# -*- coding: utf-8 -*-
# from qcloud_cos.demo import client
import time

# Form implementation generated from reading ui file 'in.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.、

# 引用
import source_rc
import os
import sys
import linecache
import atexit
import traceback
from threading import Thread
import logging
from qcloud_cos import CosConfig
from qcloud_cos import CosS3Client
from qcloud_cos import CosServiceError
from qcloud_cos import CosClientError
from faker import Faker
import os
from Encryptor import enc
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import *
from PySide2.QtCore import Signal, QObject
from typing import List, Union

# 初始化变量
f = Faker(locale='zh_CN')
a_key: List[Union[int, str]] = [0] * 1000
a_pas = ''
fileaddress = [0] * 1

filename_list = ['0'] * 10000
filename_rd = [0] * 10000
filename_r = [0] * 10000
filename_rlist = ['0'] * 10000

filer = 0
walktime = 1

isok = 0
loglevel = 0
timex = 0


class preload:
    def __init__(self):
        # 初始化日志
        self.log_name = str(time.strftime("%Y-%m-%d_%H-%M-%S", time.localtime())) + str('.log')
        logging.basicConfig(filename=self.log_name, filemode="w",
                            format="%(asctime)s %(name)s:%(levelname)s:%(message)s",
                            datefmt="%d-%M-%Y %H:%M:%S", level=logging.DEBUG)
        logging.debug("初始化变量完成！")
        # 初始化上帝系统


preload()


# 设置日志等级
class statuschange(QObject):
    sc = Signal(QStatusBar, str)


class updatex(QObject):
    pb1c = Signal(QProgressBar, int)


# 重制TextBrowser为拖拽作准备
class MyTB(QTextBrowser):
    global fileaddress

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)

    def dragEnterEvent(self, event):
        fileaddress[0] = (event.mimeData().urls()[0].toLocalFile())
        logging.debug('Now Dragpath is ' + str(fileaddress[0]))
        # print(fileaddress[0])

    logging.debug("TextBrowser拖拽重写完成！")


class LoadCOSError(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return self.value
class WrongCOSPASError(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return self.value


# 加载主窗口
class Ui_MainWindow(QtWidgets.QMainWindow):

    def __init__(self):
        super(Ui_MainWindow, self).__init__()
        self.paths = ""
        self.setupUi(self)
        self.retranslateUi(self)
        self.setAcceptDrops(True)  # ==> 必须设置、
        self.save_stdout = sys.stdout
        sys.stdout = self
        self.ups = updatex()
        self.ups.pb1c.connect(self.changeint)
        self.old_hook = sys.excepthook
        sys.excepthook = self.catch_exceptions



    def catch_exceptions(self, t, v, tb):
        logging.critical(t)
        logging.critical(v)
        logging.critical(tb)
        QMessageBox.warning(self, '警告', '程序出现严重错误，请重新打开！')

    def changeint(self, sf, num):
        sf.setValue(int(num))
        logging.debug('changeint/sf/num' + str(sf) + str(num))

    # 输出重写
    def write(self, message):
        logging.info(message)

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(378, 275)
        MainWindow.setMaximumSize(QtCore.QSize(378, 275))
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.tabWeiget_main = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWeiget_main.setGeometry(QtCore.QRect(0, 0, 371, 260))
        self.tabWeiget_main.setMaximumSize(QtCore.QSize(371, 260))
        self.tabWeiget_main.setBaseSize(QtCore.QSize(371, 251))
        self.tabWeiget_main.setTabPosition(QtWidgets.QTabWidget.North)
        self.tabWeiget_main.setTabShape(QtWidgets.QTabWidget.Rounded)
        self.tabWeiget_main.setObjectName("tabWeiget_main")
        self.select = QtWidgets.QWidget()
        self.select.setAccessibleName("")
        self.select.setObjectName("select")
        self.TB1_main = MyTB(self.select)
        self.TB1_main.setGeometry(QtCore.QRect(40, 10, 291, 121))
        self.TB1_main.setAcceptDrops(True)
        self.TB1_main.setAutoFillBackground(True)
        self.TB1_main.setObjectName("TB1_main")
        self.Lb1_uploadto = QtWidgets.QLabel(self.select)
        self.Lb1_uploadto.setGeometry(QtCore.QRect(40, 150, 48, 16))
        self.Lb1_uploadto.setObjectName("Lb1_uploadto")
        self.CB1_bucket = QtWidgets.QComboBox(self.select)
        self.CB1_bucket.setGeometry(QtCore.QRect(93, 150, 141, 19))
        self.CB1_bucket.setObjectName("CB1_bucket")
        self.PB1 = QtWidgets.QProgressBar(self.select)
        self.PB1.setGeometry(QtCore.QRect(40, 180, 301, 20))
        self.PB1.setProperty("value", 0)
        self.PB1.setObjectName("PB1")
        self.B1_upload = QtWidgets.QPushButton(self.select)
        self.B1_upload.setGeometry(QtCore.QRect(250, 150, 75, 23))
        self.B1_upload.setObjectName("B1_upload")
        self.B1_upload.setEnabled(False)
        # self.lb1l_status = QtWidgets.QLabel(self.select)
        # self.lb1l_status.setGeometry(QtCore.QRect(10, 210, 171, 16))
        # self.lb1l_status.setObjectName("lb1l_status")
        self.tabWeiget_main.addTab(self.select, "")
        self.output = QtWidgets.QWidget()
        self.output.setObjectName("output")
        self.TB2_output = QtWidgets.QTextBrowser(self.output)
        self.TB2_output.setGeometry(QtCore.QRect(20, 10, 331, 181))
        self.TB2_output.setObjectName("TB2_output")
        self.CB2_isautoclear = QtWidgets.QCheckBox(self.output)
        self.CB2_isautoclear.setGeometry(QtCore.QRect(30, 200, 68, 16))
        self.CB2_isautoclear.setObjectName("CB2_isautoclear")
        self.B2_clearall = QtWidgets.QPushButton(self.output)
        self.B2_clearall.setGeometry(QtCore.QRect(270, 200, 75, 23))
        self.B2_clearall.setObjectName("B2_clearall")
        self.tabWeiget_main.addTab(self.output, "")
        self.secret = QtWidgets.QWidget()
        self.secret.setObjectName("secret")
        self.groupBox = QtWidgets.QGroupBox(self.secret)
        self.groupBox.setGeometry(QtCore.QRect(0, 0, 361, 171))
        self.groupBox.setObjectName("groupBox")
        self.LB3_region = QtWidgets.QLabel(self.groupBox)
        self.LB3_region.setGeometry(QtCore.QRect(10, 150, 36, 16))
        self.LB3_region.setObjectName("LB3_region")
        self.LE3_mykey = QtWidgets.QLineEdit(self.groupBox)
        self.LE3_mykey.setGeometry(QtCore.QRect(80, 41, 161, 20))
        self.LE3_mykey.setEchoMode(QLineEdit.Password)
        self.LE3_mykey.setObjectName("LE3_mykey")
        self.LE3_mykey.EchoMode(QLineEdit.Password)
        self.LE3_sid = QtWidgets.QLineEdit(self.groupBox)
        self.LE3_sid.setGeometry(QtCore.QRect(80, 71, 161, 20))
        self.LE3_sid.setObjectName("LE3_sid")
        self.LB3_skey = QtWidgets.QLabel(self.groupBox)
        self.LB3_skey.setGeometry(QtCore.QRect(9, 97, 58, 16))
        self.LB3_skey.setObjectName("LB3_skey")
        self.LE3_skey = QtWidgets.QLineEdit(self.groupBox)
        self.LE3_skey.setGeometry(QtCore.QRect(80, 96, 161, 20))
        self.LE3_skey.setObjectName("LE3_skey")
        self.LB3_sec = QtWidgets.QLabel(self.groupBox)
        self.LB3_sec.setGeometry(QtCore.QRect(9, 42, 88, 16))
        self.LB3_sec.setObjectName("LB3_sec")
        self.LB3_sid = QtWidgets.QLabel(self.groupBox)
        self.LB3_sid.setGeometry(QtCore.QRect(9, 72, 52, 16))
        self.LB3_sid.setObjectName("LB3_sid")
        self.LE3_region = QtWidgets.QLineEdit(self.groupBox)
        self.LE3_region.setGeometry(QtCore.QRect(80, 150, 161, 20))
        self.LE3_region.setObjectName("LE3_region")
        self.LB3_bucket = QtWidgets.QLabel(self.groupBox)
        self.LB3_bucket.setGeometry(QtCore.QRect(10, 120, 36, 16))
        self.LB3_bucket.setObjectName("LB3_bucket")
        self.B3_save = QtWidgets.QPushButton(self.groupBox)
        self.B3_save.setGeometry(QtCore.QRect(260, 110, 91, 31))
        self.B3_save.setObjectName("B3_save")
        self.B3_load = QtWidgets.QPushButton(self.groupBox)
        self.B3_load.setGeometry(QtCore.QRect(260, 60, 91, 31))
        self.B3_load.setObjectName("B3_load")
        self.LB3_1_loadfilename = QtWidgets.QLabel(self.groupBox)
        self.LB3_1_loadfilename.setGeometry(QtCore.QRect(80, 20, 261, 16))
        self.LB3_1_loadfilename.setObjectName("LB3_1_loadfilename")
        self.LB3_1_now_load = QtWidgets.QLabel(self.groupBox)
        self.LB3_1_now_load.setGeometry(QtCore.QRect(10, 20, 341, 16))
        self.LB3_1_now_load.setObjectName("LB3_1_now_load")
        self.LE3_bucket = QtWidgets.QLineEdit(self.groupBox)
        self.LE3_bucket.setGeometry(QtCore.QRect(80, 120, 151, 20))
        self.LE3_bucket.setObjectName("LE3_bucket")
        self.B3_quebucket = QtWidgets.QPushButton(self.groupBox)
        self.B3_quebucket.setGeometry(QtCore.QRect(230, 120, 16, 21))
        self.B3_quebucket.setObjectName("B3_quebucket")
        self.groupBox_2 = QtWidgets.QGroupBox(self.secret)
        self.groupBox_2.setGeometry(QtCore.QRect(0, 180, 361, 51))
        self.groupBox_2.setObjectName("groupBox_2")
        self.CB3_2_israndomname = QtWidgets.QCheckBox(self.groupBox_2)
        self.CB3_2_israndomname.setGeometry(QtCore.QRect(21, 24, 128, 16))
        self.CB3_2_israndomname.setObjectName("CB3_2_israndomname")
        self.CB3_2_islog = QtWidgets.QCheckBox(self.groupBox_2)
        self.CB3_2_islog.setGeometry(QtCore.QRect(155, 24, 68, 16))
        self.CB3_2_islog.setObjectName("CB3_2_islog")
        self.CB3_2_loglevel = QtWidgets.QComboBox(self.groupBox_2)
        self.CB3_2_loglevel.setGeometry(QtCore.QRect(229, 23, 60, 19))
        self.CB3_2_loglevel.setEditable(False)
        self.CB3_2_loglevel.setDuplicatesEnabled(False)
        self.CB3_2_loglevel.setObjectName("CB3_2_loglevel")
        self.CB3_2_loglevel.addItem("")
        self.CB3_2_loglevel.addItem("")
        self.CB3_2_loglevel.addItem("")
        self.CB3_2_save = QtWidgets.QPushButton(self.groupBox_2)
        self.CB3_2_save.setGeometry(QtCore.QRect(300, 22, 51, 21))
        self.CB3_2_save.setObjectName("CB3_2_save")
        self.tabWeiget_main.addTab(self.secret, "")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 378, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        # self.statusbar.showMessage('Test Message')
        self.tabWeiget_main.setCurrentIndex(0)
        logging.debug("窗口绘制完毕")

        # 初始化槽函数
        self.tabWeiget_main.currentChanged.connect(self.tabchange)
        self.B3_load.clicked.connect(self.click_B3)
        self.B1_upload.clicked.connect(self.click_B1)
        self.B2_clearall.clicked.connect(self.click_B2)
        self.CB3_2_save.clicked.connect(self.click_CB3_2)
        self.B3_quebucket.clicked.connect(self.quemessage)
        self.B3_save.clicked.connect(self.click_B3_save)
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        logging.debug("槽函数编写完成")

        # 上帝模式
        sudoload = 'C:\\ProgramData\\COS_uploader_config.sudo.enc'
        if os.path.exists(sudoload):
            try:
                self.loadCOS(sudoload)
            except LoadCOSError as e:
                self.statusbar.showMessage('系统存在上帝模式文件，但加载失败，请手动加载参数')
                logging.debug(e)
            try:
                self.CheckCOS(sudoload)
            except WrongCOSPASError as e:
                self.statusbar.showMessage('系统存在上帝模式文件，但校验未通过，请手动加载参数')
                logging.debug(e)
            self.statusbar.showMessage('系统已加载上帝模式文件，可以直接使用！')
            _translate = QtCore.QCoreApplication.translate
            MainWindow.setWindowTitle(_translate("COS_uploader", "COS_uploader:上帝模式"))
        else:
            pass

    # 绘制UI
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("COS_uploader", "COS_uploader"))
        self.TB1_main.setHtml(_translate("MainWindow",
                                         "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
                                         "<html><head><meta name=\"qrichtext\" content=\"1\" /><title>设置一个居中的图片</title><style type=\"text/css\">\n"
                                         "p, li { white-space: pre-wrap; }\n"
                                         "</style></head><body style=\" font-family:\'SimSun\'; font-size:9pt; font-weight:400; font-style:normal;\">\n"
                                         "<p align=\"center\" style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\'SimHei\';\"><br /></p>\n"
                                         "<p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><img src=\":/pic/in.svg\" width=\"120\" height=\"80\" /><span style=\" font-family:\'SimHei\';\"> </span></p>\n"
                                         "<p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:\'SimHei\';\">将文件或文件夹拖拽到此处</span></p></body></html>"))
        self.Lb1_uploadto.setText(_translate("MainWindow", "上传至："))
        self.B1_upload.setText(_translate("MainWindow", "开始上传"))
        self.statusbar.showMessage('等待加载参数...')
        self.tabWeiget_main.setTabText(self.tabWeiget_main.indexOf(self.select), _translate("MainWindow", "上传"))
        self.CB2_isautoclear.setText(_translate("MainWindow", "自动清空"))
        self.B2_clearall.setText(_translate("MainWindow", "清空"))
        self.tabWeiget_main.setTabText(self.tabWeiget_main.indexOf(self.output), _translate("MainWindow", "输出"))
        self.groupBox.setTitle(_translate("MainWindow", "Config"))
        self.LB3_region.setText(_translate("MainWindow", "Region"))
        self.LB3_skey.setText(_translate("MainWindow",
                                         "<html><head/><body><p><span style=\" color:#aa0000; vertical-align:super;\">*</span>secretkey</p></body></html>"))
        self.LB3_sec.setText(_translate("MainWindow",
                                        "<html><head/><body><p><span style=\" color:#aa0000; vertical-align:super;\">*</span>MyKey</p></body></html>"))
        self.LB3_sid.setText(_translate("MainWindow",
                                        "<html><head/><body><p><span style=\" color:#aa0000; vertical-align:super;\">*</span>secretid</p></body></html>"))
        self.LB3_bucket.setText(_translate("MainWindow", "Bucket"))
        self.B3_save.setText(_translate("MainWindow", "SaveConfig"))
        self.B3_load.setText(_translate("MainWindow", "LoadConfig"))
        self.LB3_1_loadfilename.setText(_translate("MainWindow", "UNKNOWN"))
        self.LB3_1_now_load.setText(_translate("MainWindow", "当前加载为："))
        self.B3_quebucket.setText(_translate("MainWindow", "?"))
        self.groupBox_2.setTitle(_translate("MainWindow", "Profile"))
        self.CB3_2_israndomname.setText(_translate("MainWindow", "强力随机文件名上传"))
        self.CB3_2_islog.setText(_translate("MainWindow", "输出日志"))
        self.CB3_2_loglevel.setItemText(0, _translate("MainWindow", "0-简单"))
        self.CB3_2_loglevel.setItemText(1, _translate("MainWindow", "1-基本"))
        self.CB3_2_loglevel.setItemText(2, _translate("MainWindow", "2-详细"))
        self.CB3_2_loglevel.setCurrentIndex(1)
        self.CB3_2_islog.setChecked(True)
        self.CB3_2_save.setText(_translate("MainWindow", "Save"))
        self.tabWeiget_main.setTabText(self.tabWeiget_main.indexOf(self.secret),
                                       _translate("MainWindow", "参数配置"))
        logging.debug("UI重绘完成")

    # 事件：切换到参数窗口
    def judgepath(self, path):
        # 0文件夹 1文件
        if os.path.isdir(path):
            logging.debug("judgepath=0")
            return 0
        elif os.path.isfile(path):
            logging.debug("judgepath=1")
            return 1

    def quemessage(self):
        QMessageBox.information(self, "Bucket", "可以写入一个或多个Bucket，中间用英文分号分割哦")

    def tabchange(self):
        global a_key
        global a_pas
        global setlevel
        logging.debug("Tabchange!")
        # 初始化页面
        if self.tabWeiget_main.currentIndex() == 2:
            # 把之前的writeio拆开写，当存在文件时
            if a_key[0] == 0:  # 不存在变量
                logging.info("self.LB3_1_now_load.setText('请创建/打开一个参数文件！')")
                self.LB3_1_now_load.setText('请创建/打开一个参数文件！')
                self.LB3_1_loadfilename.setText('')

    def click_B3_save(self):
        if self.LE3_mykey.text() == 'sudo':
            QMessageBox.warning(self, '警告', '您将要保存为上帝模式的参数，详细见Readme！')
            self.saveCOSfile('COS_uploader_config.sudo','C:\\ProgramData\\COS_uploader_config.sudo')
        else:
            self.saveCOSfile('SAVECOS.secret','SAVECOS.secret')



    def saveCOSfile(self,filename,filepath):
        try:
            fx = open(filepath, "w")
            # 这之前要统计一下有多少个bucket
            fx.write(str(len((self.LE3_bucket.text()).split(';'))) + "\n")
            logging.debug('开始写入！' + str(len((self.LE3_bucket.text()).split(';'))) + "/" + self.LE3_mykey.text())
            logging.debug(
                self.LE3_sid.text() + '/' + self.LE3_skey.text() + '/' + self.LE3_region.text() + '/' + self.LE3_bucket.text())
            fx.write(self.LE3_mykey.text() + "\n")
            fx.write(self.LE3_sid.text() + "\n")
            fx.write(self.LE3_skey.text() + "\n")
            fx.write(self.LE3_region.text() + "\n")
            fx.write(self.LE3_bucket.text() + "\n")
            fx.close()
            enc.encrypt_file(filepath)
            logging.info('写入'+str(filename)+'.enc成功')
            QMessageBox.information(self, "COS_uploader", '写入'+str(filename)+'.enc成功')
        except(IOError, TypeError):
            QMessageBox.warning(self, '警告', '在保存参数时出现了异常')
            logging.error("在保存参数时出现了异常")

    def click_CB3_2(self):
        # 输出日志事件
        global loglevel
        if self.CB3_2_islog.isChecked() == True:
            logger = logging.getLogger()
            if self.CB3_2_loglevel.currentIndex() == 0:
                logger.setLevel(logging.ERROR)
                loglevel = 0
            if self.CB3_2_loglevel.currentIndex() == 1:
                logger.setLevel(logging.INFO)
                loglevel = 1
            if self.CB3_2_loglevel.currentIndex() == 2:
                logger.setLevel(logging.DEBUG)
                loglevel = 2
        logging.debug('日志事件创建完成！等级' + str(loglevel))
        QMessageBox.information(self, "提示", '参数' + str(loglevel) + '保存成功！')
        logging.info(str(loglevel) + '保存成功！')

    # 事件：点击B3
    def click_B2(self):
        self.TB2_output.clear()
        logging.debug("CLEAR!")
        # 测试自定义按钮

    # 对加载参数进行重写，本来想用封装类的方法搞，但以失败告终，还是用函数答辩
    def loadCOS(self, COSfilename_e):
        try:
            enc.decrypt_file(COSfilename_e)
            logging.debug('decryptd' + str(COSfilename_e))
            # writein COS.secret in a_key
            # 这块要重写
            COSfilename = COSfilename_e[:-4]
            logging.debug('COSfilename=' + str(COSfilename))
            with open(COSfilename, 'r', encoding='UTF-8') as file:
                time_cos = 0
                for line in file:
                    a_key[time_cos] = line.strip()
                    logging.debug('分割原始参数中，a_key[time_cos]' + str(a_key[time_cos]) + str(time_cos))
                    time_cos = time_cos + 1
            enc.encrypt_file(COSfilename)
            logging.debug('decryptd' + str(COSfilename))
        except(IOError, ValueError):
            raise LoadCOSError('读取COS参数文件失败')
        pass

    def CheckCOS(self,COSfilename_e):
        global isok
        if a_key[1] == self.LE3_mykey.text() or a_key[1] == 'sudo':  # 密码正确
            # 开始加载变量
            self.LB3_1_now_load.setText('当前加载为：')
            self.LB3_1_loadfilename.setText(COSfilename_e[:-4])
            self.LE3_mykey.setText(str(a_key[1]))
            self.LE3_sid.setText(str(a_key[2]))
            self.LE3_skey.setText(str(a_key[3]))
            self.LE3_region.setText(str(a_key[4]))
            self.LE3_bucket.setText(str(a_key[5]))
            isok = 1
            self.B1_upload.setEnabled(True)
            # 将参数加载到第一页的选择库栏
            # 首先将bucket分割，后赋值给a_key
            list1: list[str] = str(a_key[5]).split(';')
            timel = int(5)
            for i in list1:
                a_key[timel] = i
                timel = timel + 1
                logging.debug('开始转移参数' + str(timel))
            # 进行一个参数的加载
            self.CB1_bucket.clear()
            self.CB1_bucket.addItems(list1)
            logging.debug("参数已全部加载")
        else:
            raise WrongCOSPASError('参数校验未通过')
        pass

    def click_B3(self):
        global isok
        COSfilename_e, fd = QFileDialog.getOpenFileName(self, '选择一个参数文件', './',
                                                        '参数文件(*.secret.enc)', '参数文件(*.secret.enc)')
        if self.LE3_mykey.text() == '':  # 用户没有输入Mykey，弹窗提醒输入
            logging.info("Lost MyKey")
            QMessageBox.warning(self, "警告", "请输入MyKey！", QMessageBox.Cancel)
        else:
            if COSfilename_e != '':
                try:
                    self.loadCOS(COSfilename_e)
                except LoadCOSError as e:
                    QMessageBox.warning(self,'警告','在加载参数时出现了异常')
                    logging.error('在加载参数时出现了异常')
                    logging.error(e)
                # 到此步，已将COS.secret加载到变量中，下一步开始比对密码值
                try:
                    self.CheckCOS(COSfilename_e)
                    QMessageBox.information(self, "提示", "参数加载成功！")
                    self.statusbar.showMessage('参数加载成功！')
                    logging.info("参数加载成功！")
                    _translate = QtCore.QCoreApplication.translate
                    MainWindow.setWindowTitle(_translate("COS_uploader", "COS_uploader"))
                except WrongCOSPASError as e:
                    QMessageBox.warning(self, "注意", "Mykey校验未通过，请重新输入！", QMessageBox.Cancel)
                    self.statusbar.showMessage('Mykey校验未通过，请重新输入！')
                    logging.info("Mykey校验未通过，请重新输入！")
                    logging.info(e)
            else:
                QMessageBox.warning(self, "警告", "请选择文件", QMessageBox.Cancel)
                self.statusbar.showMessage('请选择文件！')
                logging.info("警告, 请选择文件")

    # 尝试用双多线程改写

    # 函数：进度条回调，计算当前上传的百分比
    def upload_percentage(self, consumed_bytes, total_bytes):
        # 进度条回调函数，计算当前上传的百分比
        if total_bytes:
            rate = int(100 * (float(consumed_bytes) / float(total_bytes)))
            logging.debug('回传进度Rate=' + str(rate))
            self.ups.pb1c.emit(self.PB1, int(rate))
            logging.debug("发送信号Rate")

    # 搬来的上传文件函数
    def uploadfile(self, upfilepath, upfilename):
        try:
            ##### -----1.连接桶部分-----#####
            # 进行链接配置
            logging.debug('上传文件：loglevel=' + str(loglevel))
            if loglevel == 1:
                logging.basicConfig(level=logging.INFO, stream=sys.stdout)
            if loglevel == 2:
                logging.basicConfig(level=logging.DEBUG, stream=sys.stdout)
            self.statusbar.showMessage('开始上传！')
            logging.info("开始上传")
            config = CosConfig(Region=a_key[4], SecretId=a_key[2],
                               SecretKey=a_key[3], Token=None, Scheme='https')  # type: ignore
            logging.debug('COS上传参数' + str(a_key[4]) + '/' + str(a_key[2]) + '/' + str(a_key[3]))
            client = CosS3Client(config)
            ##### -----2.开始上传-----#####
            self.statusbar.showMessage('开始上传' + upfilepath + '啦~', 5)
            logging.info('开始上传' + str(upfilepath) + '啦~')
            # 主要的上传函数
            self.response = client.upload_file(
                Bucket=bucketx,
                Key=upfilename,
                LocalFilePath=upfilepath,
                EnableMD5=False,
                progress_callback=self.upload_percentage
            )
            ##### -----3.总结-----#####
            self.statusbar.showMessage(upfilepath + '上传成功！', 5)
            logging.info(str(upfilepath) + '上传成功！')
            self.PB1.setValue(100)
            # join
            self.TB2_output.append(
                upfilepath + '的文件地址为' + 'https://' + bucketx + '.cos.' + a_key[4] + '.myqcloud.com/' + upfilename)
            self.TB2_output.append('\n')
        except (CosServiceError, CosClientError):
            self.statusbar.showMessage('上传COS中出现异常，请确定参数是否正确以及网络是否畅通')
            logging.info('上传COS中出现异常，请确定参数是否正确以及网络是否畅通')

    def isfilerp_check(self, jbucket, jfilename, w):
        try:
            # 可以开多线程，判断文件是否重复
            # global filename
            # global fileext
            global filer
            config = CosConfig(Region=a_key[4], SecretId=a_key[2],
                               SecretKey=a_key[3], Token=None, Scheme='https')  # type: ignore
            logging.debug('在查找重复文件名线程中，参数加载完毕！')
            client = CosS3Client(config)
            response = client.object_exists(
                Bucket=jbucket,
                Key=jfilename)
            logging.debug('开始判断文件' + jfilename + '有无重名？')
            if response == True:  # 文件名重复
                filename_rd[filer] = w
                filename_r[w] = 114514
                filer += 1
                logging.debug('文件' + jfilename + '重名')
            else:
                filename_r[w] = 0
                logging.debug('文件' + jfilename + '没有重名')
        except (CosServiceError, CosClientError):
            self.statusbar.showMessage('上传COS中出现异常，请确定参数是否正确以及网络是否畅通')
            logging.info('上传COS中出现异常，请确定参数是否正确以及网络是否畅通')

    # 事件：点击B1
    def userjudge(self, i):
        # filename_list[filename_rd[i]]
        logging.debug('文件' + filename_list[filename_rd[i]] + '重名!')
        messageBox = QMessageBox()
        messageBox.setWindowTitle('警告')
        messageBox.setWindowIcon(QtGui.QIcon(":/pic/Warning.svg"))
        # 来个图标
        messageBox.setText(
            '当前上传文件' + filename_list[filename_rd[i]] + '与库中原有文件重名，继续上传将覆盖原有文件，是否继续？')
        messageBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)
        buttonY = messageBox.button(QMessageBox.Yes)
        buttonY.setText('忽略')
        buttonN = messageBox.button(QMessageBox.No)
        buttonN.setText('更改上传文件名')
        buttonC = messageBox.button(QMessageBox.Cancel)
        buttonC.setText('上传随机文件名')
        messageBox.exec_()
        logging.debug('点击了' + str(messageBox.clickedButton()))
        # 分割文件名
        (xfilename, xfileext) = os.path.splitext(filename_list[filename_rd[i]])
        if messageBox.clickedButton() == buttonN:
            textttt, ok = QInputDialog.getText(self, '提示', '文件名重复，请输入新的文件名（不含拓展名）')
            if ok:
                filenamep = textttt + xfileext
            else:
                QMessageBox.warning(self, "警告", "您未输入文件名，将上传随机文件名！")
                filenamep = f.pystr() + xfileext
            logging.debug('返回了文件名' + str(filenamep))
        if messageBox.clickedButton() == buttonC:
            filenamep = f.pystr() + xfileext
            logging.debug('返回了文件名' + str(filenamep))
        if messageBox.clickedButton() == buttonY:
            filenamep = filename_list[filename_rd[i]]
            logging.debug('返回了文件名' + str(filenamep))
        # 反向赋值
        filename_rlist[filename_rd[i]] = filenamep

    def click_B1(self):
        global fileaddress
        global bucketx
        global filer
        global filename_list
        global filename_rd
        filer = 0
        # 检验环境变量是否存在，不要忘了bucketx是桶名
        bucketx = (self.CB1_bucket.currentText())
        logging.debug('bucketx=' + str(bucketx))
        # 处理前面的自动清除
        if self.CB2_isautoclear.isChecked():
            self.TB2_output.clear()
            logging.debug('清空了一次文件输出!')
        if isok == 1:
            # 可以上传，要看拖拽过来的是文件还是文件夹
            if self.judgepath(fileaddress[0]) != 1 and self.judgepath(fileaddress[0]) != 0:
                QMessageBox.warning('警告', '无法处理拖拽的文件！')
            walktime = 1
            if self.judgepath(fileaddress[0]) == 1:
                # 拖拽的为文件
                if self.CB3_2_israndomname.isChecked() == True:
                    logging.debug('检测到已勾选全部随机文件名，将不会检查！')
                    # 直接随机文件名上传
                    (lfilepath, lfilename) = os.path.split(str(fileaddress[0]))
                    (lfilename2, lext) = os.path.split(str(lfilename))
                    lfilenamef = f.pystr() + lext
                    thread = Thread(target=self.uploadfile, args=(fileaddress[0], lfilenamef))
                    thread.start()
                else:
                    # 没有随机文件名，需要进行检查(单个）
                    (filepathx, filenamex) = os.path.split(str(fileaddress[0]))
                    self.isfilerp_check(bucketx, filenamex, 0)
                    if filename_r[0] == 114514:
                        # 文件重名
                        print('sssss')
                        (l2filepath, l2filename) = os.path.split(str(fileaddress[0]))
                        filename_list[0] = l2filename
                        self.userjudge(0)
                        # 开始上传文件
                        thread = Thread(target=self.uploadfile, args=(fileaddress[0], filename_rlist[0]))
                        thread.start()
                    else:
                        # 文件没有重名
                        thread = Thread(target=self.uploadfile, args=(fileaddress[0], filenamex))
                        thread.start()

            if self.judgepath(fileaddress[0]) == 0:
                # 拖拽的为文件夹
                g = os.walk(str(fileaddress[0]))
                # 开始读取文件夹内全部文件
                for path, dir_list, file_list in g:
                    for file_name in file_list:
                        # 注意这里要加载纯文件名
                        # filename_list[int(walktime)] = str(fileaddress[0]) + "/" + file_name
                        filename_list[int(walktime)] = file_name
                        logging.debug('当前filename_list' + str(walktime) + ':' + str(filename_list[int(walktime)]))
                        walktime += 1
                if self.CB3_2_israndomname.isChecked() == False:
                    # 开始将全部文件名以多线程加载到判断中
                    for i in range(1, walktime):
                        thread = Thread(target=self.isfilerp_check,
                                        args=(bucketx, filename_list[i], i))
                        logging.debug('多线程：子进程isfilerp开始' + str(bucketx) + '///' + str(filename_list[int(i)]))
                        thread.start()
                        # 程序停止等待进程结束
                        thread.join()
                    # 开始将重复文件询问给用户
                    for i in range(filer):
                        # 调用判断语句
                        self.userjudge(i)
                    # 总算可以上传了
                    for i in range(1, walktime):
                        # 记得加上文件路径
                        Rfilewpath = str(fileaddress[0]) + "/" + filename_list[i]
                        if filename_r[i] == 114514:
                            # 重名，真实文件名在filename_rlist
                            Rfilename = filename_rlist[i]
                        else:
                            Rfilename = filename_list[i]
                        thread = Thread(target=self.uploadfile, args=(Rfilewpath, Rfilename))
                        thread.start()
                else:
                    # 强制随机文件名上传
                    for i in range(1, walktime):
                        Rfilewpath = str(fileaddress[0]) + "/" + filename_list[i]
                        thread = Thread(target=self.uploadfile, args=(Rfilewpath, filename_list[i]))
                        thread.start()


if __name__ == "__main__":
    import sys
    QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)  # 高分屏匹配
    app = QtWidgets.QApplication(sys.argv)
    app.setWindowIcon(QIcon(":/pic/MainLogo.svg"))
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    logging.debug('窗体已被加载！')
    sys.exit(app.exec_())
